|top
CLOCK_50 => CLOCK_50.IN1
reset => reset.IN1
GPIO[0] <> controller_top:controller.GPIO
GPIO[1] <> controller_top:controller.GPIO
GPIO[2] <> controller_top:controller.GPIO
GPIO[3] <> controller_top:controller.GPIO
GPIO[4] <> controller_top:controller.GPIO
GPIO[5] <> controller_top:controller.GPIO
GPIO[6] <> controller_top:controller.GPIO
GPIO[7] <> controller_top:controller.GPIO
GPIO[8] <> controller_top:controller.GPIO
GPIO[9] <> controller_top:controller.GPIO
GPIO[10] <> controller_top:controller.GPIO
GPIO[11] <> controller_top:controller.GPIO
GPIO[12] <> controller_top:controller.GPIO
GPIO[13] <> controller_top:controller.GPIO
GPIO[14] <> controller_top:controller.GPIO
GPIO[15] <> controller_top:controller.GPIO
GPIO[16] <> controller_top:controller.GPIO
GPIO[17] <> controller_top:controller.GPIO
GPIO[18] <> controller_top:controller.GPIO
GPIO[19] <> controller_top:controller.GPIO
GPIO[20] <> controller_top:controller.GPIO
GPIO[21] <> controller_top:controller.GPIO
GPIO[22] <> controller_top:controller.GPIO
GPIO[23] <> controller_top:controller.GPIO
GPIO[24] <> controller_top:controller.GPIO
GPIO[25] <> controller_top:controller.GPIO
GPIO[26] <> controller_top:controller.GPIO
GPIO[27] <> controller_top:controller.GPIO
GPIO[28] <> controller_top:controller.GPIO
GPIO[29] <> controller_top:controller.GPIO
GPIO[30] <> controller_top:controller.GPIO
GPIO[31] <> controller_top:controller.GPIO
GPIO[32] <> controller_top:controller.GPIO
GPIO[33] <> controller_top:controller.GPIO
GPIO[34] <> controller_top:controller.GPIO
GPIO[35] <> controller_top:controller.GPIO
LEDR[0] <= controller_top:controller.LEDR
LEDR[1] <= controller_top:controller.LEDR
LEDR[2] <= controller_top:controller.LEDR
LEDR[3] <= controller_top:controller.LEDR
LEDR[4] <= controller_top:controller.LEDR
LEDR[5] <= controller_top:controller.LEDR
LEDR[6] <= controller_top:controller.LEDR
LEDR[7] <= controller_top:controller.LEDR
LEDR[8] <= controller_top:controller.LEDR
LEDR[9] <= controller_top:controller.LEDR
LEDR[10] <= controller_top:controller.LEDR
LEDR[11] <= controller_top:controller.LEDR
tx <= uart_tx8:uart.tx
busy <= uart_tx8:uart.busy


|top|controller_top:controller
CLOCK_50 => CLOCK_50.IN1
reset => reset.IN1
LEDR[0] <= controller_reader:controller.LEDR
LEDR[1] <= controller_reader:controller.LEDR
LEDR[2] <= controller_reader:controller.LEDR
LEDR[3] <= controller_reader:controller.LEDR
LEDR[4] <= controller_reader:controller.LEDR
LEDR[5] <= controller_reader:controller.LEDR
LEDR[6] <= controller_reader:controller.LEDR
LEDR[7] <= controller_reader:controller.LEDR
LEDR[8] <= controller_reader:controller.LEDR
LEDR[9] <= controller_reader:controller.LEDR
LEDR[10] <= controller_reader:controller.LEDR
LEDR[11] <= controller_reader:controller.LEDR
GPIO[0] <> <UNC>
GPIO[1] <> <UNC>
GPIO[2] <> <UNC>
GPIO[3] <> <UNC>
GPIO[4] <> <UNC>
GPIO[5] <> <UNC>
GPIO[6] <> <UNC>
GPIO[7] <> <UNC>
GPIO[8] <> <UNC>
GPIO[9] <> <UNC>
GPIO[10] <> <UNC>
GPIO[11] <> <UNC>
GPIO[12] <> <UNC>
GPIO[13] <> <UNC>
GPIO[14] <> <UNC>
GPIO[15] <> <UNC>
GPIO[16] <> <UNC>
GPIO[17] <> <UNC>
GPIO[18] <> <UNC>
GPIO[19] <> <UNC>
GPIO[20] <> <UNC>
GPIO[21] <> <UNC>
GPIO[22] <> <UNC>
GPIO[23] <> controller_reader:controller.PIN_START_C
GPIO[24] <> <UNC>
GPIO[25] <> controller_reader:controller.PIN_RIGHT_MODE
GPIO[26] <> <UNC>
GPIO[27] <> controller_reader:controller.PIN_LEFT_X
GPIO[28] <> <UNC>
GPIO[29] <> controller_reader:controller.select
GPIO[30] <> <UNC>
GPIO[31] <> controller_reader:controller.PIN_DOWN_Y
GPIO[32] <> <UNC>
GPIO[33] <> controller_reader:controller.PIN_A_B
GPIO[34] <> <UNC>
GPIO[35] <> controller_reader:controller.PIN_UP_Z


|top|controller_top:controller|controller_reader:controller
clk => mode.CLK
clk => output_z.CLK
clk => y.CLK
clk => output_x.CLK
clk => c.CLK
clk => b.CLK
clk => right.CLK
clk => left.CLK
clk => down.CLK
clk => up.CLK
clk => start.CLK
clk => a.CLK
clk => counter[0].CLK
clk => counter[1].CLK
clk => counter[2].CLK
clk => counter[3].CLK
clk => counter[4].CLK
clk => counter[5].CLK
clk => counter[6].CLK
clk => counter[7].CLK
clk => counter[8].CLK
clk => counter[9].CLK
clk => counter[10].CLK
clk => counter[11].CLK
clk => select~reg0.CLK
clk => state~10.DATAIN
reset => state.STATE_SEVEN.OUTPUTSELECT
reset => state.STATE_SIX.OUTPUTSELECT
reset => state.STATE_FIVE.OUTPUTSELECT
reset => state.STATE_FOUR.OUTPUTSELECT
reset => state.STATE_THREE.OUTPUTSELECT
reset => state.STATE_TWO.OUTPUTSELECT
reset => state.STATE_ONE.OUTPUTSELECT
reset => state.STATE_ZERO.OUTPUTSELECT
reset => state.STATE_IDLE.OUTPUTSELECT
reset => counter[0].ACLR
reset => counter[1].ACLR
reset => counter[2].ACLR
reset => counter[3].ACLR
reset => counter[4].ACLR
reset => counter[5].ACLR
reset => counter[6].ACLR
reset => counter[7].ACLR
reset => counter[8].ACLR
reset => counter[9].ACLR
reset => counter[10].ACLR
reset => counter[11].ACLR
reset => select~reg0.PRESET
reset => mode.ENA
reset => a.ENA
reset => start.ENA
reset => up.ENA
reset => down.ENA
reset => left.ENA
reset => right.ENA
reset => b.ENA
reset => c.ENA
reset => output_x.ENA
reset => y.ENA
reset => output_z.ENA
PIN_UP_Z => up.DATAB
PIN_UP_Z => output_z.DATAB
PIN_DOWN_Y => down.DATAB
PIN_DOWN_Y => y.DATAB
PIN_LEFT_X => left.DATAB
PIN_LEFT_X => output_x.DATAB
PIN_RIGHT_MODE => right.DATAB
PIN_RIGHT_MODE => mode.DATAB
PIN_A_B => a.DATAB
PIN_A_B => b.DATAB
PIN_START_C => c.DATAB
PIN_START_C => start.DATAB
select <= select~reg0.DB_MAX_OUTPUT_PORT_TYPE
LEDR[0] <= mode.DB_MAX_OUTPUT_PORT_TYPE
LEDR[1] <= start.DB_MAX_OUTPUT_PORT_TYPE
LEDR[2] <= output_z.DB_MAX_OUTPUT_PORT_TYPE
LEDR[3] <= y.DB_MAX_OUTPUT_PORT_TYPE
LEDR[4] <= output_x.DB_MAX_OUTPUT_PORT_TYPE
LEDR[5] <= c.DB_MAX_OUTPUT_PORT_TYPE
LEDR[6] <= b.DB_MAX_OUTPUT_PORT_TYPE
LEDR[7] <= a.DB_MAX_OUTPUT_PORT_TYPE
LEDR[8] <= right.DB_MAX_OUTPUT_PORT_TYPE
LEDR[9] <= left.DB_MAX_OUTPUT_PORT_TYPE
LEDR[10] <= down.DB_MAX_OUTPUT_PORT_TYPE
LEDR[11] <= up.DB_MAX_OUTPUT_PORT_TYPE


|top|uart_tx8:uart
clk => clk.IN1
rst => rst.IN1
data[0] => data[0].IN1
data[1] => data[1].IN1
data[2] => data[2].IN1
data[3] => data[3].IN1
data[4] => data[4].IN1
data[5] => data[5].IN1
data[6] => data[6].IN1
data[7] => data[7].IN1
start => sending.OUTPUTSELECT
start => state.OUTPUTSELECT
start => state.OUTPUTSELECT
start => state.OUTPUTSELECT
tx <= uart_tx:uart.tx
busy <= sending.DB_MAX_OUTPUT_PORT_TYPE


|top|uart_tx8:uart|uart_tx:uart
clk => sending.CLK
clk => busy~reg0.CLK
rst => sending.ACLR
rst => busy~reg0.ACLR
start => always0.IN1
data[0] => ~NO_FANOUT~
data[1] => ~NO_FANOUT~
data[2] => ~NO_FANOUT~
data[3] => ~NO_FANOUT~
data[4] => ~NO_FANOUT~
data[5] => ~NO_FANOUT~
data[6] => ~NO_FANOUT~
data[7] => ~NO_FANOUT~
tx <= <VCC>
busy <= busy~reg0.DB_MAX_OUTPUT_PORT_TYPE


